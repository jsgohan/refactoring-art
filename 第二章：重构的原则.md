# 重构的原则

## 何谓重构

- 名词定义：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可礼节性，降低其修改成本
- 动词定义：使用一系列重构手法，在不改变软件可观察行为的前提下，调整期结构

重构的**关键在于运用大量微小且保持软件行为的步骤，一步步达成大规模的修改**。每个单独的重构要么很小，要么由若干小步骤组合而成。因此，在重构过程中，不应该出现代码不可工作的状态。换句话说，**如果代码在重构过程中有一两天的时间不可用，基本上可以确定，他们在做的不是重构**。

### 重构与性能优化

#### 相似处

- 都需要修改代码，并且两者不会改变程序的整体功能

#### 不同处

- 重构是为了让代码"更容易理解，更易于修改"。可能是程序运行得更快，也有可能更慢
- 性能优化则只关心让程序运行得更快，最终得到的代码可能更难理解和维护

使用重构技术开发软件时，可以把时间分配给两个行为：**添加新功能和重构**。添加新功能时，不应该修改既有代码，只管添加新功能。通过添加测试并让测试正常运行，可以衡量自己的工作进度。重构时就不能再添加功能，只管调整代码的结构。此时不应该添加任何测试，只在绝对必要时才修改测试。

## 为何重构

### 重构改进软件的设计

如果没有重构，程序的内部设计(或叫做架构)会逐渐腐败变质。经常性的重构有助于代码维持自己该有的形态。

改进设计的一个重要方向就是消除重复代码，代码量减少将使未来可能的程序修改动作容易得多。

### 重构使软件更容易理解

### 重构帮助找到bug

重构能够帮助更有效地写出健壮的代码。

### 重构提高编程速度

系统开发中往往存在两种局面：一种是刚开始开发进展很快，之后需要添加新功能时不考虑重构，导致开发时间长得多。接下来塞到现有代码中的时间越来越长，不断蹦出新的bug修复也不容易修改。最终不断地累加后，程序员受不了产生重写整个系统的想法；另一种则是在添加新功能时，利用已有的功能，基于已有的功能快速构建新功能，速度自然是很快的。

上面介绍的其实就是两种团队，区别就在于软件的内部质量。**因此通过投入精力改善内部设计，增加了软件的耐久性，从而可以更长时间地保持开发的快速，这也是作者提出的"设计耐久性假说"**。

## 何时重构

### 预备性重构：让添加新功能更容易

重构的最佳时机就在添加新功能之前。

### 帮助理解的重构：使代码更易懂

在开始修改代码前，一般都要先理解代码是在做什么。通过重构，可以把理解转移到代码本身。随后运行这个软件，看是否正常工作，来检查这些理解是否正确。在研读代码时，重构会获得更高层面的理解，如果只是阅读代码很难有此领悟。

### 捡垃圾式重构

### 有计划的重构和见机行事的重构

实际重构是不需要专门安排一段时间来处理的。一般在添加功能或修复bug的同时顺便重构。这里也有一个误区，"肮脏的代码必须重构，但漂亮的代码不需要重构"，后半句是不对的，要衡量实际的情况，判断是否需要对已经整洁的代码进行重构。

优秀的程序员知道，添加新功能最快的方法往往是先修改现有的代码，使功能容易被加入。而将重构与添加新功能在版本控制的提交中分开作者认为是没有必要的，重构常常与新添加功能是紧紧交织的，不值得花时间把它们分开。只要记住：**分离重构提交并不是毋庸置疑的原则，只有当你真的感到有益时，才值得这样做**。

### 长期重构

对于很多重构可能需要很长的时间，甚至要几个星期。对于这种类型的重构，可以让整个团队达成共识，在未来几周时间里逐步解决这个问题。如果有人靠近了"重构区"额代码，就把它朝想要的方向进行改进推动。好处在于重构不会破坏代码--每次小改动之后，整个系统仍然照常工作。对于正在使用的库，可以先引入一层新的抽象，使其兼容新旧两个库的接口。一旦调用方法已经完全改为使用这层抽象，再替换掉原来的库。

### 复审代码时重构

一些公司会做常规的代码复审(code review)，因为这种活动可以改善开发状况。代码复审有助于在开发团队中传播知识，也有助于让较有经验的开发者把知识传递给比较欠缺经验的人，并帮助更多人理解大型软件系统中的更多部分。

如何在代码复审的过程中加入重构，要取决于复审的形式。一种方式为常见的pull request模式下，复审者独自浏览代码，代码的作者不在旁边，此时进行重构效果并不会好；另一种则是，代码的原作者在旁边，原作者提供关于代码的上下文信息，并且充分认同复审者进行修改的意图。**第二种方式很自然地导向结对编程：在编程过程中持续不断地进行代码复审**。

### 何时不应该重构

只有当需要理解其工作原理时，才去做重构，才会有价值。如果该代码隐藏在一个API之下，那这个情况下在不了解原理的情况下，尽量别重构。

而对于重构和重做，需要衡量重构花的时间和重做时间到底哪个更长些。决定到底应该重构还是重写，需要良好的判断力与丰富的经验。

## 重构的挑战

### 延缓新功能的开发

