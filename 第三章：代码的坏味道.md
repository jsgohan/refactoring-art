# 代码的坏味道

知道"如何"不代表知道"何时"，决定**何时重构及何时停止**和知道**重构机制如何运转**一样重要！

Kent Beck提出了用味道来形容重构的时机。

作者并不试图制定一个何时必须重构的精确衡量标准。从经验来看，没有任何量度规矩比得上见识广博者的直觉。对于开发者，必须培养自己的判断力，学会判断一个类内有多少实例变量算是太大，一个函数内有多少行代码才算太长。

## 坏味道条款

- [神秘命名(Mysterious Name)](#神秘命名)
- [重复代码(Duplicated Code)](#重复代码)
- [过长函数(Long Function)](#过长函数)
- [过长参数列表(Long Parameter List)](#过长参数列表)
- [全局数据(Global Data)](全局数据)
- [可变数据(Mutable Data)](可变数据)
- [发散式变化(Divergent Change)](发散式变化)
- [散弹式修改(Shotgun Surgery)](散弹式修改)

### 神秘命名

整洁代码最重要的一环是好的名字，所以需要深思熟虑如何给函数、模块、变量和类命名，使它们能清晰地表明自己的功能和用法。

命名使编程中最难的两件事之一。因此改名可能是最常用的重构手法，包括改变函数声明(124)(用于给函数改名)、变量改名(137)、字段改名(244)等。

### 重复代码

一旦有重复代码的存在，阅读这些重复的代码时就必须加倍仔细，留意其间细微的差异。如果要修改重复代码，必须找出所有的副本来修改。

最单纯的重复代码就是"同一个类的两个函数含有相同的表达式"。通过提炼函数(106)、或前后移动语句(223)等方法来提炼重复的代码。

### 过长函数

每当感觉需要以注释来说明点什么的时候，就可以把需要说明的东西写进一个独立函数中，并以其用途命名。

如果函数内有大量的参数和临时变量，可能会对函数的提炼形成阻碍，或者在提炼出来的函数参数中并没有带来可读性的改善。这里可以运用以查询取代临时变量(178)来消除这些临时变量。引入参数对象(140)和保持对象完整(319)则可以将过长的参数列表变得更简洁一些。

如何确定该提炼哪一段代码呢？一个很好的技巧是：**寻找注释**。它们通常能指出代码用途和实现手法之间的语义距离。哪怕是只有一行代码，如果需要以注释说明，那也值得将它提炼到独立函数中。

对于庞大的switch语句，其中的每个分支都应该通过提炼函数编程独立的函数调用。如果有多个switch语句基于同一个条件进行分支选择，就应该使用以多态取代条件表达式。

至于循环，可以将循环和循环体内的代码提炼到一个独立的函数中。

### 过长参数列表

过长的参数列表会让人产生迷惑。处理这种问题方式很多：

- 如果可以向某个参数发起查询而获得另一个参数的值，那么可以直接使用**以查询取代参数**去掉第二个参数
- 如果是从现有的数据结构中选取出很多项，可以使用**保持对象完整**手法，直接传入原来的数据结构
- 如果几项参数同时出现，可以用**引入参数对象**将其合并成一个对象
- 同样使用**函数组合成类**也可以很有效地缩短参数列表

### 全局数据

全局数据的问题在于，从代码库的任何一个角落都可以修改它，而且没有任何机制可以探测出到底哪段代码做出了修改。

首要的防御手段是**封装变量**。把全局数据用一个函数包装起来，至少可以看到修改它的地方，并开始控制对它的访问。之后可以把它放在一个类或者模块中，只允许模块内的代码使用它，尽量控制作用域。

### 可变数据

对数据的修改经常导致出乎意料的结果和难以发现的bug。需要采用一些手段来约束对数据的更新，降低风险。

- 可以用**封装变量**确保所有数据更新操作都通过很少几个函数来进行，使其更容易监控和演进
- 如果变量在不同时候被用于存储不同的东西，可以使用**拆分变量**将其拆分为各自不同用途的变量
- 把能够通过查询计算出来的变量**以查询取代派生变量**方法处理
- 使用**函数组合成类**或者**函数组合成变换**来限制需要对变量进行修改的代码量
- 如果一个变量在其内部结构中包含了数据，通常最好不要直接修改其中的数据，而是用**将引用对象改为值对象**令其直接替换整个数据结构

### 发散式变化

一旦需要修改，只需要跳到系统的某一点，只在该处做修改。这是必须要做到的抽象，若因为修改一处代码同时牵连要修改多个函数，就会带来很严重的坏味道。

- 如果发生变化的两个方向自然地形成了先后次序，可以用**拆分阶段**将两者分开，两者通过一个清晰的数据结构进行沟通

### 散弹式修改

