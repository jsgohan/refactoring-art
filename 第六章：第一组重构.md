# 第一组重构

[提炼函数(Extract Function)](#提炼函数)

[内联函数(Inline Function)](#内联函数)

[提炼变量(Extract Variable)](#提炼变量)

[内联变量(Inline Variable)](#内联变量)

[改变函数声明(Change Function Declaration)](#改变函数声明)

[封装变量(Encapsulate Variable)](#封装变量)

[变量改名(Rename Variable)](#变量改名)

[引入参数对象(Introduce Parameter Object)](#引入参数对象)

## 提炼函数

### 动机

提炼函数的最佳观点是"将意图与实现分开"，如果需要花时间浏览一段代码才能弄清它到底在干什么，那么就应该将其提炼到一个函数中，并根据它所做的事为其命名。

写非常小的函数— 通常只有几行的长度。作者认为，一个函数一旦超过6行，就开始散发臭味。短函数常常能让编译器的优化功能运转更良好，因为短函数可以更容易地被缓存。

### 做法

命名很重要，要根据函数的意图来对它命名(以它"做什么"来命名)。

## 内联函数

提炼函数的相反操作，一般在代码中嵌套太多的间接层，使得系统中的所有函数都似乎只是对另一个函数的简单委托，造成在这些委托动作之间晕头转向，通常会使用内联函数。

还有一种情况，代码一组函数不合理，可以先内联到一个大函数中，然后在用喜欢的方式提炼出小函数。

## 提炼变量

反向重构是内联变量。

局部变量可以帮助我们将表达式分解为比较容易管理的形式。

要提炼变量，以为着要给代码中一个表达式命名。如果这个名字只在当前的函数中有意义，那么提炼变量是个不错的选择；如果这个变量名在更宽的上下文中也有意义，将其暴露出来，通常以函数的形式。

## 内联变量

反向重构是提炼变量。

有时候，变量名并不比表达式本身更具表现力。且变量可能会妨碍重构附近的代码。若果真如此，就应该通过内联的方法消除变量。

## 改变函数声明

函数是将程序拆分成小块的主要方式。函数声明则展现了如何将这些小块组合在一起工作。

函数的参数列表阐述了函数如何与外部世界共处。修改参数列表不仅能增加函数的应用范围，还能改变连接一个模块所需的条件，从而去除不必要的耦合。

如果要重构的函数属于一个具有多态性的类，那么对于该函数的每个实现版本，都需要通过"提炼出一个新函数"的方式添加一层间接，并把就函数的调用转发给新函数。如果函数的多态性是在一个类继承体系中体现，那么只需要在超类上转发即可；如果各个实现类之间并没有一个共同的超类，那么久需要在每个实现类上做转发。

如果要重构一个已对外发布的API，在提炼出新函数之后，可以暂停重构，将原来的函数声明为"不推荐使用"(deprecated)，然后给客户端一点时间转为使用新函数。

## 封装变量

如果想要搬移一处被广泛使用的数据，最好的办法往往是先以函数形式封装所有对该数据的访问。就能把"重新组织数据"的困难任务转化为"重新组织函数"这个相对较简单的任务。

封装数据能提供一个清晰的观测点，可以由此监控数据的变化和使用情况。对于所有可变的数据，只要它的作用于超出单个函数，就可以将其封装起来，只允许通过函数访问。数据的作用域越大，封装就越重要。

### 例子

```js
// 重构前
let defaultOwner = { firstName: "Martin", lastName: "Fowler" };
spaceship.owner = defaultOwner;
// 更新这段数据
defaultOwner = { firstName: "Rebecca", lastName: "Parsons" };

// 开始重构
// 定义读取和写入这段数据的函数，做基础的封装
function getDefaultOwner() { return defaultOwner; }
function setDefaultOwner(arg) { defaultOwner = arg; }
// 取值
spaceship.owner = getDefaultOwner();
// 赋值
setDefaultOwner({ firstName: "Rebecca", lastName: "Parsons" });
```

封装能控制对该数据结构的访问和重新赋值，但并不能控制对结构内部数据项的修改。如果需要把封装做的更深入，不仅控制对变量引用的修改，还要控制对变量内容的修改。可以有两种做法：

- 修改取值函数，使其返回该数据的副本

  ```js
  let defaultOwner = { firstName: "Martin", lastName: "Fowler" };
  export function getDefaultOwner() { return Object.assign({}, defaultOwner); }
  export function setDefaultOwner(arg) { defaultOwner = arg; }
  ```

- 阻止对数据的修改，比如通过封装记录实现效果

  ```js
  let defaultOwner = { firstName: "Martin", lastName: "Fowler" };
  export function getDefaultOwner() { return new Person(defaultOwner) };
  export function setDefaultOwner(arg) { defaultOwner = arg; };
  
  class Person {
    constructor(data) {
      this._lastName = data.lastName;
      this._firstName = data.firstName;
    }
    
    get lastName() { return this._lastName; }
    get firstName() { return this._firstName; }
  }
  ```

## 变量改名

如果要改名的变量只作用于一个函数(临时变量或者参数)，对其改名是最简单的，找到变量的所有引用，修改过来就行。

如果变量的作用于不止于单个函数，问题就很容易出现。通常的做法是运用封装变量。在封装的变量函数内就可以随意的修改变量的名称。

如果要改名的变量是一个常量(或者在客户端看来就像是常量的元素)，可以复制这个常量，这样既不需要封装，又可以逐步完成改名。直到全部修改完成后，再删掉旧的常量。

## 引入参数对象

一组数据项如果总是结伴同行，出没于一个又一个函数。这样一组数据就是所谓的数据泥团，可以用数据结构来代替。

将数据组织成数据结构很有价值。使用新的数据结构，参数的参数列表也能缩短。并且经过重构之后，所有使用该数据结构的函数都会通过同样的名字来访问其中的元素，从而提升代码的一致性。

而除了上面的好处，更有意义的是，一旦识别出新的数据结构，就可以重组程序的行为来使用这些结构。这个过程会使代码发生巨大的变化，将数据结构提升为新的抽象概念，可以帮助更好地理解问题域。

例子

```js
// 重构前
const station = {
  name: "ZB1",
  readings: [
    { temp: 47, time: '2016-11-10 09:10' },
    { temp: 53, time: '2016-11-10 09:10' },
    { temp: 58, time: '2016-11-10 09:10' },
    { temp: 53, time: '2016-11-10 09:10' },
    { temp: 51, time: '2016-11-10 09:10' }
  ]
};
function readingOutsideRange(station, min, max) {
  return station.readings.filter(r => r.temp < min || r.temp > max);
}

alerts = readingOutsideRange(station, operationPlan.temperatureFloor, operationPlan.temperatureCeiling);
```

上面将operationPlan对象拆开分两个字段传入，实际上很不方便扩展。较好的方式是合成为一个对象使用，而最好的方式是组合的数据声明为一个类：

```js
class NumberRange {
	constructor(min, max) {
    this._data = { min: min, max: max };
  }
  get min() { return this._data[min]; }
  get max() { return this._data[max]; }
}
```

实际上演变会先在`readingOutsideRange`函数中增加一个range参数，该参数实际是NumberRange实例。然后把min、max的实现分别替换成实例里的实现，再去掉min、max参数。具体演变后的结果会变为

```js
function readingOutsideRange(station, range) {
  return station.readings.filter(r => r.temp < range.min || r.temp >range. max);
}
```

而这个还不是最终的，我们还可以把return里对范围的实现转移到NumberRange类中，抽象出一个关于范围的具体类。演变后的结果为

```js
function readingOutsideRange(station, range) {
  return station.readings.filter(r => !range.contains(r.temp));
}

// NumberRange完整类实现
class NumberRange {
	constructor(min, max) {
    this._data = { min: min, max: max };
  }
  get min() { return this._data[min]; }
  get max() { return this._data[max]; }
  
  contains(arg) {
    return arg >= this.min && arg <= this.max;
  }
}
```

