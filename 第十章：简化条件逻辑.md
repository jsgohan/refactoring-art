# 简化条件逻辑

程序的复杂度大多来自条件逻辑。因此可以借助重构把条件逻辑变得更容易理解。

- 使用**分解条件表达式**处理复杂的条件表达式
- 用**合并条件表达式**理清逻辑组合
- 用**以卫语句取代嵌套条件表达式**表达"在主要处理逻辑之前先做检查"的意图
- **以多态取代条件表达式**可以处理switch逻辑

很多条件逻辑是用于处理特殊情况的，如处理null值。

- 可以用**引入特例**处理逻辑大多相同的情况，消除重复代码

[分解条件表达式(Decompose Conditional)](#分解条件表达式)

[合并条件表达式(Consolidate Conditional Expression)](#合并条件表达式)

[以卫语句取代嵌套条件表达式(Replace Nested Conditional with Guard Clauses)](#以卫语句取代嵌套条件表达式)

[以多态取代条件表达式(Replace Conditional with Polymorphism)](#以多态取代条件表达式)

## 分解条件表达式

程序之中，复杂的条件逻辑是最常导致复杂度上升的地点之一。大型函数本身就会使代码的可读性下降，而条件逻辑则会使代码更难阅读。

对于复杂逻辑的函数，和任何大块头代码一样，可以将它分解为多个独立的函数，根据每个小块代码的用途，为分解而得的新函数命名，并将原函数中对应的代码改为调用新函数，从而更清楚地表达自己的意图。对于条件逻辑，将每个分支条件分解成新函数还可以带来更多好处：可以突出条件逻辑，更清楚地表明每个分支的作用，并且突出每个分支的原因。

例子

```js
// 重构前
if (!aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd))
  charge = quantity * plan.summerRate;
else
  charge = quantity * plan.regularRate + plan.regularServiceCharge;
```

对上面的例子，可以将条件抽成一个函数，判断为真的分支抽成一个函数，判断为假的分支抽成一个函数。

```js
if (summer())
  charge = summerCharge();
else
  charge = regularCharge();

function summer() {
	return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd);
}

function summerCharge() {
  return quantity * plan.summerRate;
}

function regularCharge() {
  return quantity * plan.regularRate + plan.regularServiceCharge;
}
```

最后，可以将原来的if语句改成三元运算符安排条件语句

```js
// 重构后
charge = summer() ? summerCharge() : regularCharge();

function summer() {
	return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd);
}

function summerCharge() {
  return quantity * plan.summerRate;
}

function regularCharge() {
  return quantity * plan.regularRate + plan.regularServiceCharge;
}
```

## 合并条件表达式

如果一串检查条件各不相同，但最终行为一致，就应该使用"逻辑或"和"逻辑与"将它们合并为一个条件表达式。

例子

```js
// 重构前
function disabilityAmount(anEmployee) {
  if (anEmployee.seniority < 2) return 0;
  if (anEmployee.monthsDisabled > 12) return 0;
  if (anEmployee.isPartTime) return 0;
  // compute the disability amount
}
```

例子中三个条件最终的返回都是0，可以直接用逻辑或运算符来合并

```js
function disabilityAmount(anEmployee) {
  if ((anEmployee.seniority < 2)
     || (anEmployee.monthsDisabled > 12)
     || (anEmployee.isPartTime))
    return 0;
  // compute the disability amount
}
```

最后，对这个条件表达式使用提炼函数

```js
// 重构后
function disabilityAmount(anEmployee) {
  if (isNotEligableForDisability()) return 0;
  // compute the disability amount
}

function isNotEligableForDisability() {
  return ((anEmployee.seniority < 2)
     || (anEmployee.monthsDisabled > 12)
     || (anEmployee.isPartTime));
}
```

## 以卫语句取代嵌套条件表达式

条件表达式通常有两种风格。第一种风格是：两个条件分支都属于正常行为。第二种风格是：只有一个条件分支是正常行为，另一个分支则是异常的情况。

如果两条分支都是正常行为，就应该使用形如if … else …的条件表达式；如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时从函数中返回。这样的单独检查常常被称为"卫语句"(guard clauses)。

卫语句的精髓就是：给某一条分支以特别的重视。如果使用if … else …结构，对if分支和else分支的重视都是同等的。卫语句不同，告诉读者："这种情况不是本函数的核心逻辑所关心的，如果真的发生了，请做一些必要的整理工作，然后退出"。

例1

```js
// 重构前
function payAmount(employee) {
  let result;
  if (employee.isSeparated) {
    result = { amount: 0, reasonable: 'SEP' };
  } else {
    if (employee.isRetired) {
      result = { amount: 0, reasonable: 'RET' };
    } else {
      // logic to compute amount
      result = someFinalComputation();
    }
  }
  return result;
}
```

上面嵌套的条件逻辑看不清代码真实的含义。只有当前两个条件表达式都不为真的时候，这段代码才真正开始它的主要工作。

使用卫语句，去除else分支，并去掉局部变量result

```js
// 重构后
function payAmount(employee) {
  if (employee.isSeparated) return { amount: 0, reasonable: 'SEP' };
  if (employee.isRetired) return { amount: 0, reasonable: 'RET' };
  return someFinalComputation();
}
```

## 以多态取代条件表达式

